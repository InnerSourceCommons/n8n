{
  "name": "ISC - GDrive",
  "nodes": [
    {
      "parameters": {},
      "id": "7c57a8f8-4159-4c76-aeea-2fb3091d5a04",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        336,
        240
      ],
      "notes": "Starts the workflow manually."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "root-folder-id",
              "name": "rootFolderId",
              "value": "1bUftTwtzkq1AQyr3HFlivPV-FwmQ2UH7",
              "type": "string"
            },
            {
              "id": "desired-structure",
              "name": "desiredStructure",
              "value": "=[\n  {\n    name: '00 – Governance',\n    children: [\n      { name: 'Charter.gdoc' },\n      { name: 'Roles & Responsibilities.gdoc' },\n      { name: 'Style Guide (Docs).gdoc' },\n      { name: 'Workflow: Google -> GitHub' },\n      { name: 'Naming Conventions.gdoc' },\n      { name: 'Meetings & Decisions Register.gdoc' },\n      { name: 'Permissions Model.gdoc' }\n    ]\n  },\n  {\n    name: '01 – Working Groups',\n    children: [\n      { name: 'Charter.gdoc' },\n      { name: '<WG Name> – Documentation' },\n      { name: '<WG Name> – Community Onboarding' },\n      { name: '<WG Name> – Software Patterns' },\n      { name: '<WG Name> – Case Studies' },\n      { name: '<WG Name> – Training Material' },\n      { name: '<WG Name> – Tooling & Automation' }\n    ]\n  },\n  {\n    name: '02 – Public Collaboration',\n    children: [\n      { name: 'RFCs (Requests for Comment)' },\n      { name: 'Ideas, Proposals, Brainstorming' },\n      { name: 'Backlog – Proposed Projects' },\n      { name: 'Community Submissions' },\n      { name: 'Research & Source Material' }\n    ]\n  },\n  {\n    name: '03 – Drafts & Work-in-Progress',\n    children: [\n      { name: 'Articles' },\n      { name: 'Patterns' },\n      { name: 'Case Studies' },\n      { name: 'Training' },\n      { name: 'Blog Posts' },\n      { name: 'Ready for Publication to GitHub' }\n    ]\n  },\n  {\n    name: '04 – Assets & Templates',\n    children: [\n      {\n        name: 'Templates',\n        children: [\n          { name: 'Pattern Template.gdoc' },\n          { name: 'Case Study Template.gdoc' },\n          { name: 'Editorial Review Checklist.gdoc' },\n          { name: 'Working Group Charter Template.gdoc' },\n          { name: 'Governance Doc Template.gdoc' },\n          { name: 'Social Media Share Image Template.gdoc' }\n        ]\n      },\n      {\n        name: 'Brand & Visuals',\n        children: [\n          { name: 'Logo Variants' },\n          { name: 'Color Guides' },\n          { name: 'Diagrams' }\n        ]\n      }\n    ]\n  },\n  {\n    name: '05 – Credentials'\n  },\n  {\n    name: '06 – Archives',\n    children: [\n      { name: '2026' },\n      { name: '2027' }\n    ]\n  },\n  {\n    name: '07 – Community & Meetings'\n  },\n  {\n    name: '08 – Outreach & Education'\n  }\n]\n",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        560,
        240
      ],
      "id": "f68b6d4d-481a-4afc-a6be-01e1817a46ca",
      "name": "Set Configuration",
      "notes": "Sets the root folder ID and desired folder structure."
    },
    {
      "parameters": {
        "url": "https://www.googleapis.com/drive/v3/files",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleDriveOAuth2Api",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "q",
              "value": "mimeType = 'application/vnd.google-apps.folder' and trashed = false"
            },
            {
              "name": "fields",
              "value": "files(id,name,parents)"
            },
            {
              "name": "includeItemsFromAllDrives",
              "value": "true"
            },
            {
              "name": "supportsAllDrives",
              "value": "true"
            },
            {
              "name": "pageSize",
              "value": "1000"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        784,
        240
      ],
      "id": "49c8d3e6-b81f-496d-a4fa-f14f46774382",
      "name": "Get All Folders",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "Bd8OzpTQIKeOfW9k",
          "name": "Google Drive account"
        }
      },
      "notes": "Gets all folders accessible to the account (across drives). Build Actual Structure will filter this to only the subtree rooted at rootFolderId."
    },
    {
      "parameters": {
        "jsCode": "// Build hierarchical structure from flat list of folders\n// Convert Google Drive folder structure to JSON matching the desired structure format\n\nconst rootFolderId = $('Set Configuration').first().json.rootFolderId;\nconst allFolders = $json.files || [];\n\nconsole.log('Total folders found in Google Drive:', allFolders.length);\n\n// Build a map: parentId -> [children]\nconst childrenMap = new Map();\nfor (const folder of allFolders) {\n  const parentId = folder.parents && folder.parents.length > 0 ? folder.parents[0] : rootFolderId;\n  if (!childrenMap.has(parentId)) {\n    childrenMap.set(parentId, []);\n  }\n  childrenMap.get(parentId).push({\n    id: folder.id,\n    name: folder.name\n  });\n}\n\nconsole.log('Folders directly under root:', childrenMap.get(rootFolderId)?.length || 0);\n\n// Build tree structure starting directly from rootFolderId\n// Function to recursively build tree structure\nfunction buildTree(parentId) {\n  const children = childrenMap.get(parentId) || [];\n  return children.map(child => {\n    const node = { name: child.name };\n    const childChildren = buildTree(child.id);\n    if (childChildren.length > 0) {\n      node.children = childChildren;\n    }\n    return node;\n  });\n}\n\n// Build tree starting from rootFolderId (which is now a folder, not a drive root)\nconst actualStructure = buildTree(rootFolderId);\n\nconsole.log('Actual structure built:', JSON.stringify(actualStructure, null, 2));\n\nreturn [{ json: { actualStructure, allFolders } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        240
      ],
      "id": "db6ae3c3-b9e2-47ed-ad68-d005fa0a8d52",
      "name": "Build Actual Structure",
      "notes": "Converts the flat list of folders from Google Drive into a hierarchical JSON structure matching the desired format."
    },
    {
      "parameters": {
        "jsCode": "// Compare desired structure with actual structure\n// Include ALL folders with exists: true/false field\n\nconst desiredStructure = typeof $('Set Configuration').first().json.desiredStructure === 'string'\n  ? eval($('Set Configuration').first().json.desiredStructure)\n  : $('Set Configuration').first().json.desiredStructure;\n\nconst actualStructure = $json.actualStructure || [];\n\nconsole.log('Desired structure:', JSON.stringify(desiredStructure, null, 2));\nconsole.log('Actual structure:', JSON.stringify(actualStructure, null, 2));\n\n// Build a lookup map: parentName -> Map<childName, exists>\n// This allows us to check if a folder exists by its name and parent context\nfunction buildNameMap(structure, parentName = null) {\n  const nameMap = new Map(); // parentName -> Set<childNames>\n  \n  function processNode(node, parent) {\n    const parentKey = parent || 'ROOT';\n    if (!nameMap.has(parentKey)) {\n      nameMap.set(parentKey, new Set());\n    }\n    nameMap.get(parentKey).add(node.name);\n    \n    if (node.children && node.children.length > 0) {\n      for (const child of node.children) {\n        processNode(child, node.name);\n      }\n    }\n  }\n  \n  for (const node of structure) {\n    processNode(node, null);\n  }\n  \n  return nameMap;\n}\n\nconst actualNameMap = buildNameMap(actualStructure);\n\nconsole.log('Actual name map:', JSON.stringify(\n  Array.from(actualNameMap.entries()).map(([k, v]) => [k, Array.from(v)]),\n  null, 2\n));\n\n// Function to check if a folder exists by name and parent\nfunction folderExists(folderName, parentName = null) {\n  const parentKey = parentName || 'ROOT';\n  const exists = actualNameMap.has(parentKey) && actualNameMap.get(parentKey).has(folderName);\n  \n  // Debug: log what we're checking\n  if (!exists) {\n    console.log(`  Folder NOT found: name=\"${folderName}\", parent=\"${parentKey}\"`);\n    if (actualNameMap.has(parentKey)) {\n      console.log(`  Available children in ${parentKey}:`, Array.from(actualNameMap.get(parentKey)));\n    } else {\n      console.log(`  Parent ${parentKey} not found in actual structure`);\n    }\n  } else {\n    console.log(`  ✓ Folder found: name=\"${folderName}\", parent=\"${parentKey}\"`);\n  }\n  \n  return exists;\n}\n\n// Function to recursively check folders and add exists field\nfunction checkFolders(desiredNode, parentName = null) {\n  const exists = folderExists(desiredNode.name, parentName);\n  \n  console.log(`Checking folder: ${desiredNode.name}, parent: ${parentName || 'ROOT'}, exists: ${exists}`);\n  \n  const result = {\n    name: desiredNode.name,\n    exists: exists\n  };\n  \n  // Check children - always include all children\n  if (desiredNode.children && desiredNode.children.length > 0) {\n    result.children = desiredNode.children.map(child => \n      checkFolders(child, desiredNode.name)\n    );\n  }\n  \n  return result;\n}\n\n// Check all folders\nconst folderStatus = desiredStructure.map(node => checkFolders(node));\n\nconsole.log('Folder status:', JSON.stringify(folderStatus, null, 2));\n\nreturn [{ json: { folders: folderStatus } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1232,
        240
      ],
      "id": "68fbde74-2826-4dd7-85eb-fe94e4c5a655",
      "name": "Set Missing Folders",
      "notes": "Compares desired structure with actual Google Drive structure and outputs exists flags for all folders."
    },
    {
      "parameters": {
        "jsCode": "// Flatten structure and produce a list of folders to create for THIS run.\n// - Only output folders where `exists === false` AND the parent already exists.\n// - Compute parentFolderId from the current Drive state (Build Actual Structure).\n//\n// On first run: only top-level folders are created.\n// On second run: their children are created.\n// On third run: grandchildren, etc.\n//\n// You keep running the workflow until it logs \"0 folders to create\".\n\n// --- CONFIG & INPUT ---\n\nconst rootFolderId = $('Set Configuration').first().json.rootFolderId;\nconst mainFolderId = rootFolderId;\n\nconsole.log('Using rootFolderId as mainFolderId:', mainFolderId);\n\n// This comes from \"Set Missing Folders\"\nconst folderStatusTree = $json.folders || [];\n\n// From \"Build Actual Structure\" (current Drive state)\nconst actualStructure = $('Build Actual Structure').first().json.actualStructure || [];\nconst allFolders = $('Build Actual Structure').first().json.allFolders || [];\n\nconsole.log('Actual structure nodes:', actualStructure.length);\nconsole.log('Total folders in allFolders:', allFolders.length);\n\n// --- BUILD path -> folderId MAP FROM CURRENT DRIVE STATE ---\n\n// We'll reconstruct full paths like \"00 – Governance/Charter\"\nconst pathToId = new Map();\n\nfunction buildPathMap(structure, parentPath = '', parentId = mainFolderId) {\n  for (const node of structure) {\n    const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;\n\n    // Find the matching folder from allFolders by name + parentId\n    const folder = allFolders.find(f => {\n      const fParentId = f.parents && f.parents.length > 0 ? f.parents[0] : rootFolderId;\n      return f.name === node.name && fParentId === parentId;\n    });\n\n    if (folder) {\n      pathToId.set(currentPath, folder.id);\n      // Recurse into children\n      if (node.children && node.children.length > 0) {\n        buildPathMap(node.children, currentPath, folder.id);\n      }\n    }\n  }\n}\n\nbuildPathMap(actualStructure);\n\nconsole.log('Existing paths in Drive:');\nfor (const [p, id] of pathToId.entries()) {\n  console.log(`  ${p} -> ${id}`);\n}\n\n// --- FLATTEN DESIRED STRUCTURE (with exists flags) ---\n// We only output folders where:\n//   - node.exists === false\n//   - the parent \"exists\" right now (either root or in pathToId / actualStructure)\n\nfunction flattenForCreation(structure, parentPath = '', parentName = null, depth = 0, parentExists = true) {\n  const result = [];\n\n  for (const node of structure) {\n    const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;\n    const thisExists = node.exists === true;\n\n    // Decide if THIS node should be created in this run\n    // Only when it doesn't exist yet, and its parent exists.\n    if (!thisExists && parentExists) {\n      let parentFolderId;\n\n      if (!parentPath) {\n        // Top-level folder under the main/root folder\n        parentFolderId = mainFolderId;\n      } else {\n        // Parent is some subfolder; look it up by its full path\n        parentFolderId = pathToId.get(parentPath) || mainFolderId;\n      }\n\n      console.log(\n        `Scheduling create: \"${currentPath}\" ` +\n        `(depth ${depth}, parentPath=\"${parentPath}\", parentFolderId=${parentFolderId})`\n      );\n\n      result.push({\n        name: node.name,\n        path: currentPath,\n        parentPath,\n        parentName,\n        depth,\n        parentFolderId,\n      });\n    } else {\n      console.log(\n        `Skipping for now: \"${currentPath}\" (exists=${thisExists}, parentExists=${parentExists})`\n      );\n    }\n\n    // Children: their parent \"exists\" if:\n    //  - this node already exists in Drive (thisExists === true), OR\n    //  - we have a path->id entry for it (i.e., it existed before this run).\n    const childParentExists = thisExists || pathToId.has(currentPath);\n\n    if (node.children && node.children.length > 0) {\n      const childResults = flattenForCreation(\n        node.children,\n        currentPath,\n        node.name,\n        depth + 1,\n        childParentExists,\n      );\n      result.push(...childResults);\n    }\n  }\n\n  return result;\n}\n\nconst flattened = flattenForCreation(folderStatusTree);\n\n// Sort by depth so parents of this batch are before children of this batch\nflattened.sort((a, b) => a.depth - b.depth);\n\nconsole.log(`\\nFound ${flattened.length} folders to create in THIS run:`);\nflattened.forEach(f =>\n  console.log(\n    `  [depth ${f.depth}] ${f.path} (parentPath=\"${f.parentPath}\", parentFolderId=${f.parentFolderId})`,\n  ),\n);\n\n// Output each folder as a separate item\nconst outputItems = flattened.map(folder => ({\n  json: {\n    ...folder,\n    mainFolderId,\n    rootFolderId,\n  },\n}));\n\nconsole.log(`\\n=== OUTPUT: Returning ${outputItems.length} items ===`);\n\nreturn outputItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        240
      ],
      "id": "544fd73c-10e3-46f8-b174-df393c7be42d",
      "name": "Flatten Folders to Create",
      "notes": "Flattens the structure and filters to only folders with exists == false. Sorts by depth so parents are created before children."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.googleapis.com/drive/v3/files",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleDriveOAuth2Api",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "supportsAllDrives",
              "value": "true"
            },
            {
              "name": "includeItemsFromAllDrives",
              "value": "true"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  name: $json.name,\n  mimeType: 'application/vnd.google-apps.folder',\n  parents: [$json.parentFolderId]\n} }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1664,
        240
      ],
      "id": "436e4772-c867-42b8-9585-b00f2cfb0455",
      "name": "Create Folder",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "Bd8OzpTQIKeOfW9k",
          "name": "Google Drive account"
        }
      },
      "notes": "Creates a folder in Google Drive using the Google Drive API. Includes shared drive parameters to ensure folders are created in the shared drive, not My Drive."
    },
    {
      "parameters": {
        "content": "## Workflow Overview\n\nThis workflow creates a hierarchical folder structure in Google Drive by comparing a desired structure definition with the current Drive state.\n\n**How it works:**\n1. Fetches all folders from Google Drive and builds a hierarchical tree\n2. Compares desired structure with actual structure, marking each folder with `exists: true/false`\n3. Identifies folders to create: only those where `exists === false` AND their parent already exists\n4. Creates folders in batches (run multiple times until all folders are created)\n\n**Usage:** Run the workflow repeatedly until it logs \"0 folders to create\" - this ensures parents are created before children.",
        "height": 544,
        "width": 272
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1,
      "id": "b4275b50-fda3-4dc4-95e8-e36993474f97",
      "name": "Sticky Note"
    }
  ],
  "pinData": {},
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Set Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Configuration": {
      "main": [
        [
          {
            "node": "Get All Folders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get All Folders": {
      "main": [
        [
          {
            "node": "Build Actual Structure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Actual Structure": {
      "main": [
        [
          {
            "node": "Set Missing Folders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Missing Folders": {
      "main": [
        [
          {
            "node": "Flatten Folders to Create",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Flatten Folders to Create": {
      "main": [
        [
          {
            "node": "Create Folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "dd5e1022-7c1c-4fb3-940c-dc7c6d371d99",
  "meta": {
    "instanceId": "505d3f2effe3cea9c5bcf74fb293004bb613f932b3d6dd9cc01c7c68e9422333"
  },
  "id": "ULeI_q4-L9VmEufZdmlsb",
  "tags": []
}